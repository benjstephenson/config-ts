"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.concatObjects = exports.ObjectMatcher = void 0;
const DiffMatcher_1 = require("./DiffMatcher");
const ofType_1 = require("../ofType");
const MatchResult_1 = require("../MatchResult");
const Mismatched_1 = require("./Mismatched");
const DiffFieldMatcher_1 = require("./DiffFieldMatcher");
class ObjectMatcher extends DiffMatcher_1.DiffMatcher {
    constructor(expectedObject, matchers) {
        super();
        this.expectedObject = expectedObject;
        this.matchers = matchers;
        this.complexity = DiffMatcher_1.DiffMatcher.andComplexity(matchers);
    }
    static make(obj) {
        return new ObjectMatcher(obj, DiffFieldMatcher_1.DiffFieldMatcher.makeAll(obj));
    }
    mismatches(context, mismatched, actual) {
        if (!ofType_1.ofType.isObject(actual)) {
            mismatched.push(Mismatched_1.Mismatched.makeExpectedMessage(context, actual, "object expected"));
            return MatchResult_1.MatchResult.wasExpected(actual, this.describe(), 1, 0);
        }
        if (this.expectedObject === actual) {
            return MatchResult_1.MatchResult.good(1, true);
        }
        const results = {};
        let errors = 0;
        let compares = 0;
        let matches = 0;
        let matchedObjectKey = false;
        const keyMatchers = this.matchers.filter(m => m.isKey());
        if (keyMatchers.length > 0) {
            keyMatchers.forEach(e => {
                const result = e.mismatches(context, mismatched, actual);
                if (result.passed()) {
                    results[e.fieldName] = actual[e.fieldName];
                }
                else {
                    results[e.fieldName] = result.diff;
                    errors += 10;
                }
                compares += result.compares;
                matches += result.matchRate * result.compares;
            });
            if (errors === 0) {
                matchedObjectKey = true;
            }
        }
        const nonKeyMatchers = this.matchers.filter(m => !m.isKey());
        nonKeyMatchers.forEach(e => {
            const result = e.mismatches(context, mismatched, actual);
            if (result.passed()) {
                results[e.fieldName] = actual[e.fieldName];
            }
            else {
                results[e.fieldName] = result.diff;
                errors += 1;
            }
            compares += result.compares;
            matches += result.matchRate * result.compares;
        });
        const unexpected = {};
        let wasUnexpected = false;
        Object.keys(actual).forEach(key => {
            // Careful, as a field may have an explicit value of undefined:
            if (actual[key] !== undefined && results[key] === undefined) {
                unexpected[key] = actual[key];
                errors += 1;
                compares += 1;
                wasUnexpected = true;
            }
        });
        if (wasUnexpected) {
            mismatched.push(Mismatched_1.Mismatched.makeUnexpectedMessage(context, actual, unexpected));
            results[MatchResult_1.MatchResult.unexpected] = unexpected;
        }
        if (errors === 0) {
            return MatchResult_1.MatchResult.good(compares, matchedObjectKey);
        }
        return new MatchResult_1.MatchResult(results, compares, matches, matchedObjectKey);
    }
    describe() {
        return concatObjects(this.matchers.map(e => e.describe()));
    }
}
exports.ObjectMatcher = ObjectMatcher;
function concatObjects(objects) {
    const result = {};
    objects.forEach(o => Object.keys(o).forEach(key => result[key] = o[key]));
    return result;
}
exports.concatObjects = concatObjects;
//# sourceMappingURL=ObjectMatcher.js.map