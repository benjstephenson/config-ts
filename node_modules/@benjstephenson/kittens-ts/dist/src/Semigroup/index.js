"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.record = exports.getApplySemigroup = exports.fold = exports.nel = exports.array = exports.either = exports.both = exports.string = exports.product = exports.sum = exports.right = exports.left = exports.reverse = exports.from = void 0;
const NEA = __importStar(require("../NonEmptyArray"));
const from = (concat) => ({
    concat,
});
exports.from = from;
const reverse = (S) => ({
    concat: (x, y) => S.concat(y, x),
});
exports.reverse = reverse;
const left = () => ({
    concat: (a, _) => a,
});
exports.left = left;
const right = () => ({
    concat: (_, b) => b,
});
exports.right = right;
exports.sum = {
    concat: (a, b) => a + b,
};
exports.product = {
    concat: (a, b) => a * b,
};
exports.string = {
    concat: (a, b) => `${a} ${b}`,
};
exports.both = {
    concat: (a, b) => a && b,
};
exports.either = {
    concat: (a, b) => a || b,
};
const array = () => ({
    concat: (a, b) => [...a, ...b],
});
exports.array = array;
const nel = () => ({
    concat: NEA.concat,
});
exports.nel = nel;
const fold = (S, initial) => (values) => values.reduce((acc, val) => S.concat(acc, val), initial);
exports.fold = fold;
const getApplySemigroup = (F) => (S) => ({
    concat: (fa, fb) => F.ap(fa, F.map((a) => (b) => S.concat(a, b), fb)),
});
exports.getApplySemigroup = getApplySemigroup;
function record(semigroups) {
    return {
        concat: (x, y) => Object.keys(semigroups).reduce((acc, key) => {
            acc[key] = semigroups[key].concat(x[key], y[key]);
            return acc;
        }, {}),
    };
}
exports.record = record;
