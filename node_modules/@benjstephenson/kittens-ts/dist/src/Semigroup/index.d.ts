import { Apply, HKT, Kind } from '../hkt';
import * as NEA from '../NonEmptyArray';
export interface Semigroup<A> {
    readonly concat: (a: A, b: A) => A;
}
export interface SemigroupF extends HKT {
    readonly type: Semigroup<this['A']>;
}
export declare const from: <A>(concat: (x: A, y: A) => A) => Semigroup<A>;
export declare const reverse: <A>(S: Semigroup<A>) => Semigroup<A>;
export declare const left: <A>() => Semigroup<A>;
export declare const right: <A>() => Semigroup<A>;
export declare const sum: Semigroup<number>;
export declare const product: Semigroup<number>;
export declare const string: Semigroup<string>;
export declare const both: Semigroup<boolean>;
export declare const either: Semigroup<boolean>;
export declare const array: <A>() => Semigroup<A[]>;
export declare const nel: <A>() => Semigroup<NEA.NonEmptyArray<A>>;
export declare const fold: <A>(S: Semigroup<A>, initial: A) => (values: readonly A[]) => A;
export declare const getApplySemigroup: <F extends HKT, R, E>(F: Apply<F>) => <A>(S: Semigroup<A>) => Semigroup<Kind<F, R, E, A>>;
export declare function record<R extends Record<string, any>>(semigroups: {
    [K in keyof R]: Semigroup<R[K]>;
}): Semigroup<R>;
