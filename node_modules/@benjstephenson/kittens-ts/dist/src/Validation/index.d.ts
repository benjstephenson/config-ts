import * as Sg from '../Semigroup';
import { Monad, Failable, Eitherable, HKT, Kind } from '../hkt';
import * as E from '../Either';
export interface Validation<F extends HKT, E> extends HKT {
    readonly type: Kind<F, this['R'], E, this['A']>;
}
export declare const getMonadValidation: <F extends HKT>(M: Monad<F>, F: Failable<F>, E: Eitherable<F>) => <Z>(S: Sg.Semigroup<Z>) => Monad<Validation<F, Z>>;
export declare const getEitherValidation: <A>() => Monad<Validation<E.EitherF, import("../NonEmptyArray").NonEmptyArray<A>>>;
export declare const getValidationNel: <A>() => <R, E, T extends E.Either<A[] & {
    readonly 0: A;
}, any>[]>(...t: T & {
    readonly 0: E.Either<A[] & {
        readonly 0: A;
    }, any>;
}) => E.Either<A[] & {
    readonly 0: A;
}, { [K in keyof T]: [T[K]] extends [E.Either<A[] & {
    readonly 0: A;
}, infer A_1>] ? A_1 : never; }>;
export declare const getRecordValidation: <A>() => <R, E, Rec extends Record<string, E.Either<A[] & {
    readonly 0: A;
}, any>>>(fa: Rec) => E.Either<A[] & {
    readonly 0: A;
}, { [K in keyof Rec]: Rec[K] extends E.Either<A[] & {
    readonly 0: A;
}, infer A_1> ? A_1 : never; }>;
