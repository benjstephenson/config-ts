import type { Option } from './Option';
import { Apply, Functor, HKT, Monad, Applicative, ComposeF, Foldable, Traversable } from '../hkt';
import { Equal } from '../Equal';
import * as Sg from '../Semigroup';
import { Monoid } from '../Monoid';
export interface OptionF extends HKT {
    readonly type: Option<this['A']>;
}
export declare const getSemigroup: <A>(S: Sg.Semigroup<A>) => Sg.Semigroup<Option<A>>;
export declare const getMonoid: <A>(sg: Sg.Semigroup<A>) => Monoid<Option<A>>;
export declare const getEquals: <A>(eq: Equal<A>) => Equal<Option<A>>;
export declare const functor: Functor<OptionF>;
export declare const apply: Apply<OptionF>;
export declare const applicative: Applicative<OptionF>;
export declare const foldable: Foldable<OptionF>;
export declare const traversable: Traversable<OptionF>;
export declare const monad: Monad<OptionF>;
export declare function optionT<F extends HKT>(F: Monad<F>): Monad<ComposeF<F, OptionF>>;
