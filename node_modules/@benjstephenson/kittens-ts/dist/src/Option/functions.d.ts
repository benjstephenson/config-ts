import { Option } from './Option';
import { Applicative, HKT, Kind } from '../hkt';
export declare const none: <A>() => Option<A>;
export declare const some: <A>(a: A) => Option<A>;
export declare const of: <A>(a: A | undefined) => Option<A>;
export declare const map: <A, B>(f: (a: A) => B, fa: Option<A>) => Option<B>;
export declare const map_: <A, B>(f: (a: A) => B) => (fa: Option<A>) => Option<B>;
export declare const ap: <A, B>(fa: Option<A>, fab: Option<(a: A) => B>) => Option<B>;
export declare const flatMap: <A, B>(f: (a: A) => Option<B>, fa: Option<A>) => Option<B>;
export declare const flatMap_: <A, B>(f: (a: A) => Option<B>) => (fa: Option<A>) => Option<B>;
export declare const lift: <A, B>(f: (a: A) => B) => (fa: Option<A>) => Option<B>;
export declare const traverse: <F extends HKT>(F: Applicative<F>) => <R, E, A, B>(f: (a: A) => Kind<F, R, E, B>, fa: Option<A>) => Kind<F, R, E, Option<B>>;
export declare const sequence: <F extends HKT>(F: Applicative<F>) => <R, E, A>(fa: Option<Kind<F, R, E, A>>) => Kind<F, R, E, Option<A>>;
export declare function sequenceT<T extends Array<Option<any>>>(...t: T & {
    readonly 0: Option<any>;
}): Option<{
    [K in keyof T]: [T[K]] extends [Option<infer U>] ? U : never;
}>;
