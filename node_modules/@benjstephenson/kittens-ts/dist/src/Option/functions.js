"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sequenceT = exports.sequence = exports.traverse = exports.lift = exports.flatMap_ = exports.flatMap = exports.ap = exports.map_ = exports.map = exports.of = exports.some = exports.none = void 0;
const Option_1 = require("./Option");
const NonEmptyArray_1 = require("../NonEmptyArray");
const functions_1 = require("../functions");
const none = () => new Option_1.None();
exports.none = none;
const some = (a) => new Option_1.Some(a);
exports.some = some;
const isSome = (opt) => opt.tag === 'Some';
const isNone = (opt) => !isSome(opt);
const of = (a) => (a === undefined ? (0, exports.none)() : (0, exports.some)(a));
exports.of = of;
const map = (f, fa) => fa.isSome() ? (0, exports.some)(f(fa.get())) : (0, exports.none)();
exports.map = map;
const map_ = (f) => (fa) => (0, exports.map)(f, fa);
exports.map_ = map_;
const ap = (fa, fab) => (0, exports.flatMap)((f) => (0, exports.map)(f, fa), fab);
exports.ap = ap;
const flatMap = (f, fa) => isSome(fa) ? f(fa.get()) : (0, exports.none)();
exports.flatMap = flatMap;
const flatMap_ = (f) => (fa) => (0, exports.flatMap)(f, fa);
exports.flatMap_ = flatMap_;
const lift = (f) => (0, exports.map_)(f);
exports.lift = lift;
const traverse = (F) => (f, fa) => fa.isNone()
    ? F.of((0, exports.none)())
    : F.ap(f(fa.get()), F.of((b) => (0, exports.some)(b)));
exports.traverse = traverse;
const sequence = (F) => (fa) => (0, exports.traverse)(F)((x) => x, fa);
exports.sequence = sequence;
function sequenceT(...list) {
    // TODO figure out how to unapply this list so we can reuse sequence.
    if (!(0, NonEmptyArray_1.isNonEmptyArray)(list))
        return (0, exports.none)();
    const head = list[0];
    const tail = list.splice(1);
    return tail.reduce((acc, v) => acc.flatMap((h) => v.map((b) => (0, functions_1.tuple)(...h, b))), head.map(functions_1.tuple));
}
exports.sequenceT = sequenceT;
