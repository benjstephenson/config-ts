import * as Eq from '../Equal';
import * as E from '../Either';
export declare type Option<A> = Some<A> | None<A>;
export declare const OptionURI = "Option";
export declare type OptionURI = typeof OptionURI;
interface OptionFns<A> {
    isSome(): this is Some<A>;
    isNone(): this is None<A>;
    equals(other: Option<A>, eq: Eq.Equal<A>): boolean;
    map<B>(f: (a: A) => B): Option<B>;
    flatMap<B>(f: (a: A) => Option<B>): Option<B>;
    getOrElse(_default: A): A;
    getOrCall(f: () => A): A;
    toEither<E>(e: E): E.Either<E, A>;
}
export declare class Some<A> implements OptionFns<A> {
    private readonly value;
    readonly tag = "Some";
    constructor(value: A);
    R?: unknown;
    E?: unknown;
    equals(other: Option<A>, eq?: Eq.Equal<A>): boolean;
    isSome(): this is Some<A>;
    isNone(): this is None<A>;
    get(): A;
    map<B>(f: (a: A) => B): Option<B>;
    flatMap<B>(f: (a: A) => Option<B>): Option<B>;
    getOrElse(_default: A): A;
    getOrCall(_f: () => A): A;
    toEither<E>(e: E): E.Either<E, A>;
}
export declare class None<A> implements OptionFns<A> {
    readonly tag = "None";
    isSome(): this is Some<A>;
    isNone(): this is None<A>;
    equals(other: Option<A>, eq?: Eq.Equal<A>): boolean;
    map<B>(f: (a: A) => B): Option<B>;
    flatMap<B>(f: (a: A) => Option<B>): Option<B>;
    getOrElse(fallback: A): A;
    getOrCall(f: () => A): A;
    toEither<E>(e: E): E.Either<E, A>;
}
export {};
