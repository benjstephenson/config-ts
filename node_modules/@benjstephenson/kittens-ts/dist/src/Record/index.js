"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sequence = exports.traverse = exports.unit = exports.keys = void 0;
const keys = (r) => Object.keys(r);
exports.keys = keys;
exports.unit = {};
// export function sequenceR<R extends Record<string, E.Either<string, any>>>(
//   record: R
// ): E.Either<string[], { [K in keyof R]: R[K] extends E.Either<string[], infer A> ? A : never }>
// export function sequenceR(record: Record<string, E.Either<string, any>>): E.Either<string[], Record<string, any>> {
//   const [head, ...tail] = Object.keys(record)
//   const initial = record[head].map(val => ({ [head]: val })).mapLeft(s => [s])
//   return tail.reduce(
//     (acc, key) => {
//       return E.match({
//         Left: err =>
//           E.match({
//             Left: errs => E.left([...errs, ...err]),
//             Right: _ => E.left([err]),
//           }, acc),
//         Right: val =>
//           E.match({
//             Left: errs => E.left(errs),
//             Right: rec => E.right({ ...rec, [key]: val }),
//           }, acc)
//       },
//         record[key]
//       )
//     },
//     initial
//   )
// }
const traverse = (F) => (f, ra) => {
    const recordKeys = (0, exports.keys)(ra);
    if (recordKeys.length < 1)
        return F.of(exports.unit);
    const initial = F.of({});
    return recordKeys.reduce((acc, k) => {
        return F.ap(f(ra[k]), F.map((rec) => (b) => {
            rec[k] = b;
            return rec;
        }, acc));
    }, initial);
};
exports.traverse = traverse;
function sequence(F) {
    return (fa) => (0, exports.traverse)(F)((x) => x, fa);
}
exports.sequence = sequence;
