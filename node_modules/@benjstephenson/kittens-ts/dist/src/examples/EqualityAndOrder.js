"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const A = __importStar(require("../Array"));
const Eq = __importStar(require("../Equal"));
const Ord = __importStar(require("../Orderable"));
const M = __importStar(require("../Monoid"));
const cat1 = { name: 'Mittens', lives: 8, isGrumpy: false };
const cat2 = { name: 'Mittens    ', lives: 6, isGrumpy: true };
// For records, if we can say what it means for each field to be equal, then we can derive an equality for the whole record
const catEqualityStrict = Eq.record({
    name: Eq.string,
    lives: Eq.number,
    isGrumpy: Eq.boolean,
});
catEqualityStrict.equals(cat1, cat2);
// Or we might want to use some more specific rules
const ignoreWhitespace = Eq.from((x, y) => x.trim() === y.trim());
const fuzzyLives = Eq.from((x, y) => x + 2 === y || x - 2 === y);
const maybeGrumpy = Eq.from((x, y) => x || y);
const fuzzyCatEquality = Eq.record({
    name: ignoreWhitespace,
    lives: fuzzyLives,
    isGrumpy: maybeGrumpy,
});
fuzzyCatEquality.equals(cat1, cat2);
/*
 * Sometimes we might have two related types but only know an equality check for one of them.
 * If we know how to convert from one type to another, then we can derive an equality for it too!
 *  We call this association a *contramap*
 */
// let's use JS Date, as it's awful to deal with usually.  A JS Date is really just an epoch value.
const date1 = new Date();
const date2 = new Date(new Date().setMonth(2));
// Epochs are just big numbers, and we already know how to check numbers against eachother, so lets get the epoch values and compare those.
const dateEquality = Eq.contramap((x) => x.valueOf(), Eq.number);
dateEquality.equals(date1, date2);
/*
 * Deriving Ordering
 */
// Similar concept, if we know how to order a field then we can order an array of objects
const orderCatByLives = Ord.from((a, b) => (a.lives < b.lives ? -1 : a.lives > b.lives ? 1 : 0));
A.sort([cat1, cat2], orderCatByLives);
// this ^^^ is basically the same as the usual JS way of doing it   vvv
Array.of(cat1, cat2).sort((a, b) => (a.lives < b.lives ? -1 : a.lives > b.lives ? 1 : 0));
// we're just ordering by lives, which is a number.  Can we tidy this up with a contramap?
const orderCatByLives2 = Ord.contramap((c) => c.lives, Ord.number);
A.sort([cat1, cat2], orderCatByLives2);
// nicer, and hopefully a bit easier to read. What if we wanted to sort by more than one field at a time?
// Here we need to use something called a Monoid. We'll cover that in depth elsewhere, but for now know that it's a type that allows us to
// add together other types.
const catM = Ord.getMonoid();
const bylives = Ord.contramap((x) => x.lives, Ord.number);
const byName = Ord.contramap((x) => x.name, Ord.string);
// we're 'adding together' the sort functions
const sortableCat = M.fold(catM)([bylives, byName]);
A.sort([cat1, cat2], sortableCat);
/*
 * If we know how to order something, then that implies that we know how to compare them also -> if A is ! < B && A ! > B then A must === B
 * So we can use that fact to derive a simple equality, so Orderable also implements Equal
 */
orderCatByLives2.equals(cat1, cat2);
