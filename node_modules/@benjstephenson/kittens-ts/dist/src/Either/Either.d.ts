import * as O from '../Option';
import * as Eq from '../Equal';
export declare type Either<E, A> = Left<E, A> | Right<E, A>;
interface EitherFns<E, A> {
    isLeft(): this is Left<E, A>;
    isRight(): this is Right<E, A>;
    getOrElse(other: A): A;
    equals(other: Either<E, A>, eqE: Eq.Equal<E>, eqA: Eq.Equal<A>): boolean;
    ap<B>(fab: Either<E, (r: A) => B>): Either<E, B>;
    map<B>(f: (a: A) => B): Either<E, B>;
    mapLeft<M>(f: (l: E) => M): Either<M, A>;
    flatMap<E2, B>(f: (r: A) => Either<E2, B>): Either<E | E2, B>;
    bimap<EE, AA>(fo: {
        Left: (e: E) => EE;
        Right: (a: A) => AA;
    }): Either<EE, AA>;
    fold<B>(f: (acc: B, a: A) => B, init: B): B;
    toOption(): O.Option<A>;
}
export declare class Left<E, A> implements EitherFns<E, A> {
    private readonly value;
    readonly tag = "Left";
    constructor(value: E);
    isLeft(): this is Left<E, A>;
    isRight(): this is Right<E, A>;
    equals(other: Either<E, A>, eqE?: Eq.Equal<E>, eqA?: Eq.Equal<A>): boolean;
    get(): E;
    getOrElse(other: A): A;
    ap<B>(fab: Either<E, (r: A) => B>): Either<E, B>;
    map<B>(f: (a: A) => B): Either<E, B>;
    mapLeft<M>(f: (l: E) => M): Either<M, A>;
    flatMap<E2, B>(f: (r: A) => Either<E2, B>): Either<E | E2, B>;
    bimap<EE, AA>(fo: {
        Left: (e: E) => EE;
        Right: (a: A) => AA;
    }): Either<EE, AA>;
    fold<B>(f: (acc: B, a: A) => B, init: B): B;
    toOption(): O.Option<A>;
}
export declare class Right<E, A> implements EitherFns<E, A> {
    private readonly value;
    readonly tag = "Right";
    constructor(value: A);
    isLeft(): this is Left<E, A>;
    isRight(): this is Right<E, A>;
    get(): A;
    equals(other: Either<E, A>, eqE?: Eq.Equal<E>, eqA?: Eq.Equal<A>): boolean;
    getOrElse(_other: A): A;
    ap<E2, B>(fab: Either<E2, (r: A) => B>): Either<E | E2, B>;
    map<B>(f: (a: A) => B): Either<E, B>;
    mapLeft<E2>(_f: (l: E) => E2): Either<E2, A>;
    flatMap<E2, B>(f: (r: A) => Either<E2, B>): Either<E | E2, B>;
    bimap<E2, B>(fo: {
        Left: (e: E) => E2;
        Right: (a: A) => B;
    }): Either<E2, B>;
    fold<B>(f: (acc: B, a: A) => B, init: B): B;
    toOption(): O.Option<A>;
}
export {};
