"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sequence = exports.traverse = exports.of = exports.match_ = exports.match = exports.fold = exports.bimap_ = exports.bimap = exports.flatMap_ = exports.flatMap = exports.map_ = exports.map = exports.mapLeft_ = exports.mapLeft = exports._ap = exports.ap = exports.rightWiden = exports.leftWiden = exports.isRight = exports.isLeft = exports.right = exports.left = void 0;
const Either_1 = require("./Either");
const left = (l) => new Either_1.Left(l);
exports.left = left;
const right = (r) => new Either_1.Right(r);
exports.right = right;
const isLeft = (e) => e.tag === 'Left';
exports.isLeft = isLeft;
const isRight = (e) => e.tag === 'Right';
exports.isRight = isRight;
const leftWiden = (self) => self;
exports.leftWiden = leftWiden;
const rightWiden = (self) => self;
exports.rightWiden = rightWiden;
const ap = (fa, fab) => (0, exports.flatMap)((ab) => (0, exports.map)((a) => ab(a), fa), fab);
exports.ap = ap;
const _ap = (fa) => (fab) => (0, exports.ap)(fa, fab);
exports._ap = _ap;
const mapLeft = (f, fa) => fa.isLeft() ? (0, exports.left)(f(fa.get())) : (0, exports.right)(fa.get());
exports.mapLeft = mapLeft;
const mapLeft_ = (f) => (fa) => (0, exports.mapLeft)(f, fa);
exports.mapLeft_ = mapLeft_;
const map = (f, fa) => fa.isRight() ? (0, exports.right)(f(fa.get())) : (0, exports.left)(fa.get());
exports.map = map;
const map_ = (f) => (fa) => (0, exports.map)(f, fa);
exports.map_ = map_;
const flatMap = (f, fa) => fa.isLeft() ? (0, exports.left)(fa.get()) : f(fa.get());
exports.flatMap = flatMap;
const flatMap_ = (f) => (fa) => (0, exports.flatMap)(f, fa);
exports.flatMap_ = flatMap_;
const bimap = (fo, fa) => fa.isLeft() ? (0, exports.left)(fo.Left(fa.get())) : (0, exports.right)(fo.Right(fa.get()));
exports.bimap = bimap;
const bimap_ = (fo) => (fa) => (0, exports.bimap)(fo, fa);
exports.bimap_ = bimap_;
const fold = (f, init, fa) => fa.isLeft() ? init : f(init, fa.get());
exports.fold = fold;
const match = (fo, fa) => fa.isLeft() ? fo.Left(fa.get()) : fo.Right(fa.get());
exports.match = match;
const match_ = (fo) => (fa) => (0, exports.match)(fo, fa);
exports.match_ = match_;
const of = (a) => (0, exports.right)(a);
exports.of = of;
const traverse = (F) => (f, fa) => fa.isLeft()
    ? F.of((0, exports.left)(fa.get()))
    : F.ap(f(fa.get()), F.of((x) => (0, exports.right)(x)));
exports.traverse = traverse;
const sequence = (F) => (fa) => (0, exports.traverse)(F)((x) => x, fa);
exports.sequence = sequence;
