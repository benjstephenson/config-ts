import { Applicative, HKT, Kind } from '../hkt';
import { Either, Left, Right } from './Either';
export declare const left: <E, A>(l: E) => Either<E, A>;
export declare const right: <E, A>(r: A) => Either<E, A>;
export declare const isLeft: <E, A>(e: Either<E, A>) => e is Left<E, A>;
export declare const isRight: <E, A>(e: Either<E, A>) => e is Right<E, A>;
export declare const leftWiden: <E, E2, A>(self: Either<E, A>) => Either<E | E2, A>;
export declare const rightWiden: <E, A, B>(self: Either<E, A>) => Either<E, A | B>;
export declare const ap: <E, E2, A, B>(fa: Either<E, A>, fab: Either<E2, (a: A) => B>) => Either<E | E2, B>;
export declare const _ap: <E, A>(fa: Either<E, A>) => <E2, B>(fab: Either<E2, (a: A) => B>) => Either<E | E2, B>;
export declare const mapLeft: <E, E2, A>(f: (a: E) => E2, fa: Either<E, A>) => Either<E2, A>;
export declare const mapLeft_: <E, E2, A>(f: (a: E) => E2) => (fa: Either<E, A>) => Either<E2, A>;
export declare const map: <E, A, B>(f: (a: A) => B, fa: Either<E, A>) => Either<E, B>;
export declare const map_: <E, A, B>(f: (a: A) => B) => (fa: Either<E, A>) => Either<E, B>;
export declare const flatMap: <E, E2, A, B>(f: (a: A) => Either<E2, B>, fa: Either<E, A>) => Either<E | E2, B>;
export declare const flatMap_: <E, E2, A, B>(f: (a: A) => Either<E2, B>) => (fa: Either<E, A>) => Either<E | E2, B>;
export declare const bimap: <E, E2, A, B>(fo: {
    Left: (e: E) => E2;
    Right: (a: A) => B;
}, fa: Either<E, A>) => Either<E2, B>;
export declare const bimap_: <E, E2, A, B>(fo: {
    Left: (e: E) => E2;
    Right: (a: A) => B;
}) => (fa: Either<E, A>) => Either<E2, B>;
export declare const fold: <E, A, B>(f: (acc: B, a: A) => B, init: B, fa: Either<E, A>) => B;
export declare const match: <R, E, A, B>(fo: {
    Left: (e: E) => B;
    Right: (a: A) => B;
}, fa: Either<E, A>) => B;
export declare const match_: <E, A, B>(fo: {
    Left: (e: E) => B;
    Right: (a: A) => B;
}) => (fa: Either<E, A>) => B;
export declare const of: <E, A>(a: A) => Either<E, A>;
export declare const traverse: <F extends HKT>(F: Applicative<F>) => <R, E, A, B>(f: (a: A) => Kind<F, R, E, B>, fa: Either<E, A>) => Kind<F, R, E, Either<E, B>>;
export declare const sequence: <F extends HKT>(F: Applicative<F>) => <R, E, A>(fa: Either<E, Kind<F, R, E, A>>) => Kind<F, R, E, Either<E, A>>;
