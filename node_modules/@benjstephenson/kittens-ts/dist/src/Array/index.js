"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.traversable = exports.monoid = exports.sequenceT = exports.sequence = exports.traverse = exports.fold = exports.head = exports.sort = exports.concat = exports.empty = exports.applicative = void 0;
const O = __importStar(require("../Option"));
const functions_1 = require("../functions");
const curry_1 = require("../curry");
exports.applicative = {
    of: (a) => [a],
    ap: (fa, fab) => fab.flatMap((ab) => fa.map(ab)),
    map: (f, fa) => fa.map(f),
};
const empty = () => [];
exports.empty = empty;
const concat = (x, y) => [...x, ...y];
exports.concat = concat;
const sort = (a, ord) => (a.length < 1 ? [] : a.slice().sort(ord.compare));
exports.sort = sort;
const head = (l) => (l.length > 1 ? O.of(l[0]) : O.none());
exports.head = head;
const fold = (f, init, fa) => fa.reduce(f, init);
exports.fold = fold;
const traverse = (G) => (f, fa) => {
    if (fa.length < 1)
        return G.of((0, exports.empty)());
    return fa.reduce((acc, val) => G.ap(f(val), G.map((bs) => (b) => [...bs, b], acc)), G.of((0, exports.empty)()));
};
exports.traverse = traverse;
const sequence = (G) => (fa) => (0, exports.traverse)(G)((x) => x, fa);
exports.sequence = sequence;
function sequenceT(F) {
    return (...list) => {
        const curriedTupleCtr = (0, curry_1.curry)(functions_1.tuple);
        const head = list[0];
        const tail = list.splice(1);
        return tail.reduce((acc, val) => F.ap(acc, F.map((v) => (a) => (0, functions_1.tuple)(...a, v), val)), F.map(curriedTupleCtr, head));
    };
}
exports.sequenceT = sequenceT;
const monoid = () => ({
    empty: [],
    concat: exports.concat,
});
exports.monoid = monoid;
exports.traversable = {
    traverse: exports.traverse,
    sequence: exports.sequence,
};
