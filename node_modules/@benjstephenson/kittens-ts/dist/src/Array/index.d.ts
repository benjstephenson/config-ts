import * as Ord from '../Orderable';
import * as O from '../Option';
import { Applicative, Apply, HKT, Kind, Traversable } from '../hkt';
import { Monoid } from '../Monoid';
export interface ArrayF extends HKT {
    readonly type: Array<this['A']>;
}
export declare const applicative: Applicative<ArrayF>;
export declare const empty: <A>() => A[];
export declare const concat: <A>(x: A[], y: A[]) => A[];
export declare const sort: <A>(a: A[], ord: Ord.Orderable<A>) => A[];
export declare const head: <T>(l: T[]) => O.Option<T>;
export declare const fold: <A>(f: (acc: A, cur: A) => A, init: A, fa: A[]) => A;
export declare const traverse: <G extends HKT>(G: Applicative<G>) => <R, E, A, B>(f: (a: A) => Kind<G, R, E, B>, fa: A[]) => Kind<G, R, E, B[]>;
export declare const sequence: <G extends HKT>(G: Applicative<G>) => <R, E, A>(fa: Kind<G, R, E, A>[]) => Kind<G, R, E, A[]>;
export declare function sequenceT<F extends HKT>(F: Apply<F>): <R, E, T extends Array<Kind<F, R, E, any>>>(...t: T & {
    readonly 0: Kind<F, R, E, any>;
}) => Kind<F, R, E, {
    [K in keyof T]: [T[K]] extends [Kind<F, R, E, infer A>] ? A : never;
}>;
export declare const monoid: <A>() => Monoid<A[]>;
export declare const traversable: Traversable<ArrayF>;
